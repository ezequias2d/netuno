#ifndef NT_NIR_H
#define NT_NIR_H

#include <netuno/string.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <uchar.h>

#define NIR_HANDLE(name) typedef struct _##name name;

typedef char32_t char_t;
typedef uint32_t enum_t;

NIR_HANDLE(NIR_CONTEXT)

NIR_CONTEXT *nirCreateContext(void);
void nirDestroyContext(NIR_CONTEXT *c);

/**
 * @ingroup Debug
 * @struct _NIR_DEBUG_LOC
 * @typedef NIR_DEBUG_LOC
 * @brief This type represents debug location.
 */
struct _NIR_DEBUG_LOC
{
    uint32_t checksum;
    char_t *filename;
    char_t *directory;
    size_t line;
    size_t column;
    char_t *pLine;
};
typedef struct _NIR_DEBUG_LOC NIR_DEBUG_LOC;

/**
 * @ingroup String
 * @struct _NIR_STRING
 * @typedef NIR_STRING
 * @brief This type represents a fixed length string.
 */
// struct _NIR_STRING
// {
//     char_t *start;
//     size_t length;
// };
// typedef struct _NIR_STRING NIR_STRING;

enum _NIR_SYMBOL_TYPE
{
    NIR_SYMBOL_TYPE_NONE,
    NIR_SYMBOL_TYPE_MODULE,
    NIR_SYMBOL_TYPE_FUNCTION,
    NIR_SYMBOL_TYPE_VALUE,
};
typedef enum_t NIR_SYMBOL_TYPE;

/**
 * @ingroup SymbolTable
 * @struct _NIR_SYMBOL_TABLE_ENTRY
 * @typedef NIR_SYMBOL_TABLE_ENTRY
 * @brief This type represents a symbol table entry.
 */
struct _NIR_SYMBOL_TABLE_ENTRY
{
    NT_STRING *name;
    struct _NIR_SYMBOL_TABLE *parent;
    NIR_SYMBOL_TYPE symbolType;
};
typedef struct _NIR_SYMBOL_TABLE_ENTRY NIR_SYMBOL_TABLE_ENTRY;

/**
 * @ingroup SymbolTable
 * @struct _NIR_SYMBOL_TABLE
 * @typedef NIR_SYMBOL_TABLE
 * @brief This type represents a symbol table.
 */
struct _NIR_SYMBOL_TABLE
{
    size_t count;
    size_t size;
    NIR_SYMBOL_TABLE_ENTRY **values;
};
typedef struct _NIR_SYMBOL_TABLE NIR_SYMBOL_TABLE;
typedef void (*symbolCallback)(NIR_SYMBOL_TABLE_ENTRY *entry, void *userdata);

NIR_SYMBOL_TABLE *nirCreateSymbolTable(void);
void nirDestroySymbolTable(NIR_SYMBOL_TABLE *symbolTable);
bool nirAddSymbol(NIR_SYMBOL_TABLE *symbolTable, NIR_SYMBOL_TABLE_ENTRY *entry);
NIR_SYMBOL_TABLE_ENTRY *nirFindSymbol(NIR_SYMBOL_TABLE *symbolTable,
                                      const NT_STRING *name);
NIR_SYMBOL_TABLE_ENTRY *nirRemoveSymbol(NIR_SYMBOL_TABLE *symbolTable,
                                        const NT_STRING *name);
void nirForAllSymbols(const NIR_SYMBOL_TABLE *symbolTable,
                      symbolCallback callback, void *userdata);
void nirUpdateSymbolName(NIR_SYMBOL_TABLE_ENTRY *entry, NT_STRING *newName);

#pragma region Type
/*
Type
The instances of type must be immutable. Once they are created, they never
change.
*/

NIR_HANDLE(NIR_TYPE)

enum _NIR_TYPE_ID
{
    NIR_ERROR_TYPE,

    // primitive types
    NIR_TYPE_FLOAT,
    NIR_TYPE_DOUBLE,
    NIR_TYPE_VOID,
    NIR_TYPE_LABEL,

    // derived types
    NIR_TYPE_INTEGER,
    NIR_TYPE_FUNCTION,
    NIR_TYPE_POINTER,
    NIR_TYPE_STRUCT,
    NIR_TYPE_ARRAY,
};
typedef enum_t NIR_TYPE_ID;

enum _NIR_INTEGER_BITS
{
    NIR_INTEGER_MIN_BITS = 1,
    NIR_INTEGER_MAX_BITS = (1 << (sizeof(enum_t) - 1)),
};
typedef enum_t NIR_INTEGER_BITS;

const NIR_TYPE *nirGetErrorType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetVoidType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetLabelType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetFloatType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetDoubleType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetIntegerType(NIR_CONTEXT *c, NIR_INTEGER_BITS numBits);
const NIR_TYPE *nirGetInt1Type(NIR_CONTEXT *c);
const NIR_TYPE *nirGetInt8Type(NIR_CONTEXT *c);
const NIR_TYPE *nirGetInt16Type(NIR_CONTEXT *c);
const NIR_TYPE *nirGetInt32Type(NIR_CONTEXT *c);
const NIR_TYPE *nirGetInt64Type(NIR_CONTEXT *c);
const NIR_TYPE *nirGetFunctionType(NIR_CONTEXT *c, const NIR_TYPE *result,
                                   size_t paramCount,
                                   const NIR_TYPE *const *params,
                                   bool isVarArg);

const NIR_TYPE *nirGetArrayType(NIR_CONTEXT *c, const NIR_TYPE *elementType,
                                uint64_t numElements);
const NIR_TYPE *nirGetFloatPtrType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetDoublePtrType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetIntegerPtrType(NIR_CONTEXT *c, NIR_INTEGER_BITS n);
const NIR_TYPE *nirGetInt1PtrType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetInt8PtrType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetInt16PtrType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetInt32PtrType(NIR_CONTEXT *c);
const NIR_TYPE *nirGetInt64PtrType(NIR_CONTEXT *c);

NIR_CONTEXT *nirGetTypeContext(const NIR_TYPE *type);
NIR_TYPE_ID nirGetTypeID(const NIR_TYPE *type);
bool nirIsVoidType(const NIR_TYPE *type);
bool nirIsLabelType(const NIR_TYPE *type);
bool nirIsFloatType(const NIR_TYPE *type);
bool nirIsDoubleType(const NIR_TYPE *type);
bool nirIsIntegerType(const NIR_TYPE *type);
bool nirIsIntegerNType(const NIR_TYPE *type, enum_t n);
bool nirIsFunctionType(const NIR_TYPE *type);
bool nirIsStructType(const NIR_TYPE *type);
bool nirIsArrayType(const NIR_TYPE *type);
bool nirIsPointerType(const NIR_TYPE *type);
bool nirIsFirstClassType(const NIR_TYPE *type);
bool nirIsSingleValueType(const NIR_TYPE *type);
bool nirIsAggregateType(const NIR_TYPE *type);
bool nirIsSized(const NIR_TYPE *type);
size_t nirGetPrimitiveSizeInBits(const NIR_TYPE *type);
NIR_INTEGER_BITS nirGetIntegerBitWidth(const NIR_TYPE *type);
size_t nirGetFunctionNumParams(const NIR_TYPE *type);
const NIR_TYPE *nirGetFunctionParamType(const NIR_TYPE *type, size_t i);
bool nirIsFunctionVarArg(const NIR_TYPE *type);
NT_STRING *nirGetStructName(const NIR_TYPE *type);
size_t nirGetStructNumElements(const NIR_TYPE *type);
const NIR_TYPE *nirGetStructElementType(const NIR_TYPE *type, size_t n);
size_t nirGetArrayNumElements(const NIR_TYPE *type);
const NIR_TYPE *nirGetArrayElementType(const NIR_TYPE *type);
const NIR_TYPE *nirGetPointerTo(const NIR_TYPE *type);
bool nirIsValidElementType(const NIR_TYPE *elementType);
bool nirIsValidReturnType(const NIR_TYPE *type);
bool nirIsValidArgumentType(const NIR_TYPE *type);
bool nirIsOpaque(const NIR_TYPE *type);

#pragma endregion Type

#pragma region Value
/*************/
/* NIR_VALUE */
/*************/

/**
 * @ingroup Value
 * @brief This enum identifier type of value.
 * @typedef NIR_VALUE_TYPE
 * @see @ref NIR_VALUE
 */
enum _NIR_VALUE_TYPE
{
    NIR_VALUE_TYPE_ARGUMENT,
    NIR_VALUE_TYPE_BASIC_BLOCK,
    NIR_VALUE_TYPE_CONSTANT,
    NIR_VALUE_TYPE_INSTRUCTION,
};
typedef enum_t NIR_VALUE_TYPE;

/**
 * @ingroup Value
 * @typedef NIR_VALUE
 * @struct _NIR_VALUE
 * @brief This type represents a value/single assigned register.
 * @see @ref NIR_VALUE_TYPE
 */
struct _NIR_VALUE
{
    /// @brief Symbol table entry to identify the value.
    NIR_SYMBOL_TABLE_ENTRY entry;
    /// @brief Type of value.
    NIR_VALUE_TYPE type;
    /// @brief Debug information about code that generate this value.
    NIR_DEBUG_LOC dbgLoc;
};
typedef struct _NIR_VALUE NIR_VALUE;

/**
 * @ingroup Value
 * @struct _NIR_BASIC_BLOCK_LIST
 * @typedef NIR_BASIC_BLOCK_LIST
 * @brief This type represents a list of NIR_BASIC_BLOCK values.
 * @see @ref NIR_BASIC_BLOCK
 */
struct _NIR_BASIC_BLOCK_LIST
{
    /// @brief Number of basic blocks inside this list.
    size_t count;
    /// @brief Max number of basic blocks in current basicBlocks allocation.
    size_t size;
    /// @brief Pointer to basic blocks.
    struct _NIR_BASIC_BLOCK **values;
};
typedef struct _NIR_BASIC_BLOCK_LIST NIR_BASIC_BLOCK_LIST;

/**
 * @ingroup Value
 * @struct _NIR_CONSTANT
 * @typedef NIR_CONSTANT
 * @brief This type represents a constant.
 * @see @ref NIR_VALUE
 */
struct _NIR_CONSTANT
{
    /// @brief Base value.
    NIR_VALUE value;
    /// @brief Type of value.
    const NIR_TYPE *valueType;
    /// @brief Size of data field.
    size_t numBytes;
    /// @brief Constant data.
    uint8_t *data;
};
typedef struct _NIR_CONSTANT NIR_CONSTANT;

/**
 * @ingroup Instruction
 * @brief This enum indetifier type of instruction.
 * @typedef NIR_INST_TYPE
 * @see @ref NIR_INSTRUCTION
 */
enum _NIR_INST_TYPE
{
    NIR_INST_TYPE_BINARY_OPERATOR,
    NIR_INST_TYPE_BRANCH,
    NIR_INST_TYPE_CALL,
    NIR_INST_TYPE_CMP,
    NIR_INST_TYPE_LOAD,
    NIR_INST_TYPE_PHI_NODE,
    NIR_INST_TYPE_RETURN,
    NIR_INST_TYPE_SELECT,
    NIR_INST_TYPE_STORE,
};
typedef enum_t NIR_INST_TYPE;

/**
 * @ingroup Value
 * @struct _NIR_INSTRUCTION
 * @typedef NIR_INSTRUCTION
 * @brief This type represents a instruction value.
 */
struct _NIR_INSTRUCTION
{
    /// @brief Base value.
    NIR_VALUE value;
    /// @brief Block that contain this instruction.
    struct _NIR_BASIC_BLOCK *parent;
    /// @brief Instruction type.
    NIR_INST_TYPE type;
};
typedef struct _NIR_INSTRUCTION NIR_INSTRUCTION;

/**
 * @ingroup Value
 * @struct _NIR_INST_LIST
 * @typedef NIR_INST_LIST
 * @brief This type represents a list of instructions.
 */
struct _NIR_INST_LIST
{
    /// @brief Number of instruction inside this list.
    size_t count;
    /// @brief Max number of intructions in current instructions allocation.
    size_t size;
    /// @brief Pointer to instructions.
    NIR_INSTRUCTION **values;
};
typedef struct _NIR_INST_LIST NIR_INST_LIST;

/**
 * @ingroup Value
 * @struct _NIR_BASIC_BLOCK
 * @typedef NIR_BASIC_BLOCK
 * @brief This type represents a single basic block that is a container of
 * instructions that execute sequentially.
 */
struct _NIR_BASIC_BLOCK
{
    NIR_VALUE value;              // Base value
    struct _NIR_FUNCTION *parent; // Function that contain this basic block.
    NIR_INST_LIST *instList;      // Instruction list.
};
typedef struct _NIR_BASIC_BLOCK NIR_BASIC_BLOCK;

#pragma region Instruction

enum _NIR_BINARY_OPS
{
    NIR_BINARY_OP_ADD,
    NIR_BINARY_OP_FADD,
    NIR_BINARY_OP_SUB,
    NIR_BINARY_OP_FSUB,
    NIR_BINARY_OP_MUL,
    NIR_BINARY_OP_FMUL,
    NIR_BINARY_OP_UDIV,
    NIR_BINARY_OP_SDIV,
    NIR_BINARY_OP_FDIV,
    NIR_BINARY_OP_UREM,
    NIR_BINARY_OP_SREM,
    NIR_BINARY_OP_FREM,

    NIR_BINARY_OP_SHL, // Shift left  (logical)
    NIR_BINARY_OP_SHR, // Shift right (logical)
    NIR_BINARY_OP_ASR, // Shift right (arithmetic)
    NIR_BINARY_OP_AND,
    NIR_BINARY_OP_OR,
    NIR_BINARY_OP_XOR,

    NIR_BINARY_OPS_END,
    NIR_BINARY_OPS_BEGIN = NIR_BINARY_OP_ADD,
};
typedef enum_t NIR_BINARY_OPS;

/**
 * @ingroup Instructions
 * @struct _NIR_BINARY_OPERATOR
 * @typedef NIR_BINARY_OPERATOR
 * @brief This type represents a binary operator.
 * @see @ref NIR_INSTRUCTION
 */
struct _NIR_BINARY_OPERATOR
{
    /// @brief Base instruction.
    NIR_INSTRUCTION instruction;
    /// @brief Binary operation.
    NIR_BINARY_OPS op;
    /// @brief First source value.
    NIR_VALUE *source1;
    /// @brief Second source value.
    NIR_VALUE *source2;
};
typedef struct _NIR_BINARY_OPERATOR NIR_BINARY_OPERATOR;

/**
 * @ingroup Instructions
 * @brief This type represents conditional or unconditional branch instruction.
 * @struct _NIR_BRANCH
 * @typedef NIR_BRANCH
 * @see @ref NIR_INSTRUCTION
 * @see @ref NIR_BASIC_BLOCK
 * @see @ref NIR_VALUE
 */
struct _NIR_BRANCH
{
    /// @brief Base instruction.
    NIR_INSTRUCTION instruction;
    /// @brief Target basic block when condition is true.
    NIR_BASIC_BLOCK *ifTrue;
    /// @brief Target basic block when condition is false.
    NIR_BASIC_BLOCK *ifFalse;
    /// @brief Condition, when NULL the branch is uncoditional.
    NIR_VALUE *condition;
};
typedef struct _NIR_BRANCH NIR_BRANCH;

/**
 * @ingroup Instructions
 * @brief This type represents a function call.
 * @struct _NIR_CALL
 * @typedef NIR_CALL
 * @see @ref NIR_INSTRUCTION
 * @see @ref NIR_FUNCTION
 * @see @ref NIR_VALUE
 */
struct _NIR_CALL
{
    /// @brief Base instruction.
    NIR_INSTRUCTION instruction;
    /// @brief Function called.
    struct _NIR_FUNCTION *function;
    /// @brief Number of arguments.
    size_t numArgs;
    /// @brief Arguments.
    NIR_VALUE **arguments;
};

enum _NIR_CMP_PREDICATE
{
    /// @brief True if equal
    NIR_FCMP_EQ,
    /// @brief True if greater than
    NIR_FCMP_GT,
    /// @brief True if greater than or equal
    NIR_FCMP_GE,
    /// @brief True if less than
    NIR_FCMP_LT,
    /// @brief True if less than or equal
    NIR_FCMP_LE,
    /// @brief True if operands are unequal
    NIR_FCMP_NE,
    /// @brief True if ordered: (no nan)
    NIR_FCMP_OR,
    /// @brief True if unordered: isnan(x) | isnan(y)
    NIR_FCMP_UO,

    /// @brief True if equal
    NIR_ICMP_EQ,
    /// @brief True if unequal
    NIR_ICMP_NE,
    /// @brief True if unsigned greater than
    NIR_ICMP_UGT,
    /// @brief True if unsigned greater than or equal
    NIR_ICMP_UGE,
    /// @brief True if unsigned less than
    NIR_ICMP_ULT,
    /// @brief True if unsigned less than or equal
    NIR_ICMP_ULE,

    /// @brief True if signed greater than
    NIR_ICMP_SGT,
    /// @brief True if signed greater than or equal
    NIR_ICMP_SGE,
    /// @brief True if signed less than
    NIR_ICMP_SLT,
    /// @brief True if signed less than or equal
    NIR_ICMP_SLE,
};
typedef enum_t NIR_CMP_PREDICATE;

/**
 * @ingroup Instructions
 * @brief This type represents a compare instruction
 * @struct _NIR_CMP
 * @typedef NIR_CMP
 * @see @ref NIR_INSTRUCTION
 * @see @ref NIR_CMP_PREDICATE
 */
struct _NIR_CMP
{
    /// @brief Base instruction.
    NIR_INSTRUCTION instruction;
    /// @brief Comparison predicate.
    NIR_CMP_PREDICATE predicate;
    /// @brief First source value.
    NIR_VALUE *source1;
    /// @brief Second source value.
    NIR_VALUE *source2;
};
typedef struct _NIR_CMP NIR_CMP;

/**
 * @ingroup Instructions
 * @brief This type represents a load instruction for read from memory.
 * @struct _NIR_LOAD
 * @typedef NIR_LOAD
 * @see @ref NIR_INSTRUCTION
 * @see @ref NIR_TYPE
 * @see @ref NIR_VALUE
 * @see @ref NIR_STORE
 */
struct _NIR_LOAD
{
    /// @brief Base instruction.
    NIR_INSTRUCTION instruction;
    /// @brief Type of value to load.
    NIR_TYPE *valueType;
    /// @brief Pointer to value.
    NIR_VALUE *ptr;
};
typedef struct _NIR_LOAD NIR_LOAD;

/**
 * @ingroup Instructions
 * @brief This type represents a incoming value of PHI list
 * @struct _NIR_INCOMING_VALUE
 * @typedef NIR_INCOMING_VALUE
 * @see @ref NIR_INSTRUCTION
 * @see @ref NIR_VALUE
 * @see @ref NIR_BASIC_BLOCK
 * @see @ref NIR_INCOMING_LIST
 * @see @ref NIR_PHI_NODE
 */
struct _NIR_INCOMING_VALUE
{
    NIR_VALUE *value;
    NIR_BASIC_BLOCK *basicBlock;
};
typedef struct _NIR_INCOMING_VALUE NIR_INCOMING_VALUE;

/**
 * @ingroup Instructions
 * @struct _NIR_INCOMING_LIST
 * @typedef NIR_INCOMING_LIST
 * @brief This type represents a list of NIR_INCOMING_VALUE values.
 * @brief This type represents a list of NIR_INCOMING_VALUE values.
 * @see @ref NIR_VALUE
 * @see @ref NIR_BASIC_BLOCK
 * @see @ref NIR_INCOMING_VALUE
 * @see @ref NIR_PHI_NODE
 */
struct _NIR_INCOMING_LIST
{
    /// @brief Number of incoming values inside this list.
    size_t count;
    /// @brief Max number of incoming values in a PHI Node.
    size_t size;
    /// @brief Pointer to basic blocks.
    struct _NIR_BASIC_BLOCK **values;
};
typedef struct _NIR_INCOMING_LIST NIR_INCOMING_LIST;

/**
 * @ingroup Instructions
 * @brief This type represents a PHI instruction.
 * @struct _NIR_PHI_NODE
 * @typedef NIR_PHI_NODE
 * @see @ref NIR_INSTRUCTION
 * @see @ref NIR_INCOMING_VALUE
 * @see @ref NIR_INCOMING_LIST
 * @see @ref NIR_BASIC_BLOCK
 */
struct _NIR_PHI_NODE
{
    /// @brief Base instruction.
    NIR_INSTRUCTION instruction;
    /// @brief Incoming value list.
    NIR_INCOMING_LIST *incomingList;
};
typedef struct _NIR_PHI_NODE NIR_PHI_NODE;

/**
 * @ingroup Instructions
 * @brief This type represents a return instruction.
 * @struct _NIR_RETURN
 * @typedef NIR_RETURN
 * @see @ref NIR_INSTRUCTION
 * @see @ref NIR_FUNCTION
 * @see @ref NIR_BASIC_BLOCK
 */
struct _NIR_RETURN
{
    /// @brief Base instruction.
    NIR_INSTRUCTION instruction;
    /// @brief Return value (possibly NULL for void)
    NIR_VALUE *retValue;
};
typedef struct _NIR_RETURN NIR_RETURN;

/**
 * @ingroup Instructions
 * @brief This type represents a select instruction that choose one value based
 * on a condition, without IR branch.
 * @struct _NIR_RETURN
 * @typedef NIR_RETURN
 * @see @ref NIR_INSTRUCTION
 * @see @ref NIR_VALUE
 */
struct _NIR_SELECT
{
    /// @brief Base instruction.
    NIR_INSTRUCTION instruction;
    /// @brief A i1 value indicating the condition.
    NIR_VALUE *condition;
    /// @brief The result value when condition evaluates to 1.
    NIR_VALUE *trueValue;
    /// @brief The result value when condition evaluates to 0.
    NIR_VALUE *falseValue;
};
typedef struct _NIR_SELECT NIR_SELECT;

/**
 * @ingroup Instructions
 * @brief This type represents a store instruction for write to memory.
 * @struct _NIR_STORE
 * @typedef NIR_STORE
 * @see @ref NIR_INSTRUCTION
 * @see @ref NIR_TYPE
 * @see @ref NIR_VALUE
 * @see @ref NIR_LOAD
 */
struct _NIR_STORE
{
    /// @brief Base instruction.
    NIR_INSTRUCTION instruction;
    /// @brief Type of value to load.
    NIR_TYPE *valueType;
    /// @brief Value to write.
    NIR_VALUE *value;
    /// @brief Pointer to write address.
    NIR_VALUE *ptr;
};
typedef struct _NIR_STORE NIR_STORE;

#pragma endregion Instruction

#pragma endregion Value

struct _NIR_FUNCTION
{
    NIR_SYMBOL_TABLE_ENTRY entry; // Entry.
    const NIR_TYPE *functionType;

    NIR_SYMBOL_TABLE *valueSymbolTable;
    NIR_BASIC_BLOCK_LIST *basicBlockList;
};
typedef struct _NIR_FUNCTION NIR_FUNCTION;

/**************/
/* NIR_MODULE */
/**************/

struct _NIR_MODULE
{
    NIR_SYMBOL_TABLE_ENTRY entry; // Entry.
    NIR_SYMBOL_TABLE *globalList;
    NIR_SYMBOL_TABLE *functions;
    NT_STRING *sourceFileName;
};
typedef struct _NIR_MODULE NIR_MODULE;

/**
 * @brief Creates a new module with a name.
 *
 * @param name The name of new module.
 * @return NIR_MODULE* A new module with that name.
 */
NIR_MODULE *nirCreateModule(NT_STRING *name);

/**
 * @brief Destroys a module object.
 *
 * @param module The module to destroy.
 */
void nirDestroyModule(NIR_MODULE *module);

/**
 * @brief Gets source file name.
 *
 * @param module The module to get from.
 * @return const NIR_STRING* Pointer to name.
 */
NT_STRING *nirGetSourceFileName(NIR_MODULE *module);

/**
 * @brief Sets module source file name.
 *
 * @param module Module to set source file name.
 * @param sourceFileName New source file name.
 */
void nirSetSourceFileName(NIR_MODULE *module, NT_STRING *sourceFileName);

/**
 * @brief Sets module name.
 *
 * @param module Module to set name.
 * @param name New module name.
 */
void nirSetModuleIdentifier(NIR_MODULE *module, NT_STRING *name);

/**
 * @brief Lookup the specified function in the module. If it doesn't exist, add
 * a new function and return it. This function guarantees to return a constant
 * pointer to the specified function type. If function type are wrong, return
 * the function with right type.
 *
 * @param module Module to get function from.
 * @param name Function name.
 * @param type Function type.
 * @return NIR_FUNCTION* The function with that name.
 */
NIR_FUNCTION *nirGetOrInsertFunction(NIR_MODULE *module, NT_STRING *name,
                                     const NIR_TYPE *type);

/**
 * @brief Lookup the specified function in the module symbol table.
 *
 * @param module Module to get function from.
 * @param name Function name.
 * @return NIR_FUNCTION* The function that name, or if doesn't exist, NULL.
 */
NIR_FUNCTION *nirGetFunction(NIR_MODULE *module, NT_STRING *name);

#endif
