#ifndef NT_NIL_H
#define NT_NIL_H

#include <netuno/string.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <uchar.h>

#define NIL_HANDLE(name) typedef struct _##name name;

typedef char32_t char_t;
typedef uint32_t enum_t;

NIL_HANDLE(NIL_CONTEXT)

NIL_CONTEXT *nilCreateContext(void);
void nilDestroyContext(NIL_CONTEXT *c);

/**
 * @ingroup Debug
 * @struct _NIL_DEBUG_LOC
 * @typedef NIL_DEBUG_LOC
 * @brief This type represents debug location.
 */
struct _NIL_DEBUG_LOC
{
    uint32_t checksum;
    char_t *filename;
    char_t *directory;
    size_t line;
    size_t column;
    char_t *pLine;
};
typedef struct _NIL_DEBUG_LOC NIL_DEBUG_LOC;

/**
 * @ingroup String
 * @struct _NIL_STRING
 * @typedef NIL_STRING
 * @brief This type represents a fixed length string.
 */
// struct _NIL_STRING
// {
//     char_t *start;
//     size_t length;
// };
// typedef struct _NIL_STRING NIL_STRING;

enum _NIL_SYMBOL_TYPE
{
    NIL_SYMBOL_TYPE_NONE,
    NIL_SYMBOL_TYPE_MODULE,
    NIL_SYMBOL_TYPE_FUNCTION,
    NIL_SYMBOL_TYPE_VALUE,
};
typedef enum_t NIL_SYMBOL_TYPE;

/**
 * @ingroup SymbolTable
 * @struct _NIL_SYMBOL_TABLE_ENTRY
 * @typedef NIL_SYMBOL_TABLE_ENTRY
 * @brief This type represents a symbol table entry.
 */
struct _NIL_SYMBOL_TABLE_ENTRY
{
    NT_STRING *name;
    struct _NIL_SYMBOL_TABLE *parent;
    NIL_SYMBOL_TYPE symbolType;
};
typedef struct _NIL_SYMBOL_TABLE_ENTRY NIL_SYMBOL_TABLE_ENTRY;

/**
 * @ingroup SymbolTable
 * @struct _NIL_SYMBOL_TABLE
 * @typedef NIL_SYMBOL_TABLE
 * @brief This type represents a symbol table.
 */
struct _NIL_SYMBOL_TABLE
{
    size_t count;
    size_t size;
    NIL_SYMBOL_TABLE_ENTRY **values;
};
typedef struct _NIL_SYMBOL_TABLE NIL_SYMBOL_TABLE;
typedef void (*symbolCallback)(NIL_SYMBOL_TABLE_ENTRY *entry, void *userdata);

NIL_SYMBOL_TABLE *nilCreateSymbolTable(void);
void nilDestroySymbolTable(NIL_SYMBOL_TABLE *symbolTable);
bool nilAddSymbol(NIL_SYMBOL_TABLE *symbolTable, NIL_SYMBOL_TABLE_ENTRY *entry);
NIL_SYMBOL_TABLE_ENTRY *nilFindSymbol(NIL_SYMBOL_TABLE *symbolTable,
                                      const NT_STRING *name);
NIL_SYMBOL_TABLE_ENTRY *nilRemoveSymbol(NIL_SYMBOL_TABLE *symbolTable,
                                        const NT_STRING *name);
void nilForAllSymbols(const NIL_SYMBOL_TABLE *symbolTable,
                      symbolCallback callback, void *userdata);
void nilUpdateSymbolName(NIL_SYMBOL_TABLE_ENTRY *entry, NT_STRING *newName);

#pragma region Type
/*
Type
The instances of type must be immutable. Once they are created, they never
change.
*/

NIL_HANDLE(NIL_TYPE)

enum _NIL_TYPE_ID
{
    NIL_ERROR_TYPE,

    // primitive types
    NIL_TYPE_FLOAT,
    NIL_TYPE_DOUBLE,
    NIL_TYPE_VOID,
    NIL_TYPE_LABEL,

    // derived types
    NIL_TYPE_INTEGER,
    NIL_TYPE_FUNCTION,
    NIL_TYPE_POINTER,
    NIL_TYPE_STRUCT,
    NIL_TYPE_ARRAY,
};
typedef enum_t NIL_TYPE_ID;

enum _NIL_INTEGER_BITS
{
    NIL_INTEGER_MIN_BITS = 1,
    NIL_INTEGER_MAX_BITS = (1 << (sizeof(enum_t) - 1)),
};
typedef enum_t NIL_INTEGER_BITS;

const NIL_TYPE *nilGetErrorType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetVoidType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetLabelType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetFloatType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetDoubleType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetIntegerType(NIL_CONTEXT *c, NIL_INTEGER_BITS numBits);
const NIL_TYPE *nilGetInt1Type(NIL_CONTEXT *c);
const NIL_TYPE *nilGetInt8Type(NIL_CONTEXT *c);
const NIL_TYPE *nilGetInt16Type(NIL_CONTEXT *c);
const NIL_TYPE *nilGetInt32Type(NIL_CONTEXT *c);
const NIL_TYPE *nilGetInt64Type(NIL_CONTEXT *c);
const NIL_TYPE *nilGetFunctionType(NIL_CONTEXT *c, const NIL_TYPE *result,
                                   size_t paramCount,
                                   const NIL_TYPE *const *params,
                                   bool isVarArg);

const NIL_TYPE *nilGetArrayType(NIL_CONTEXT *c, const NIL_TYPE *elementType,
                                uint64_t numElements);
const NIL_TYPE *nilGetFloatPtrType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetDoublePtrType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetIntegerPtrType(NIL_CONTEXT *c, NIL_INTEGER_BITS n);
const NIL_TYPE *nilGetInt1PtrType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetInt8PtrType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetInt16PtrType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetInt32PtrType(NIL_CONTEXT *c);
const NIL_TYPE *nilGetInt64PtrType(NIL_CONTEXT *c);

NIL_CONTEXT *nilGetTypeContext(const NIL_TYPE *type);
NIL_TYPE_ID nilGetTypeID(const NIL_TYPE *type);
bool nilIsVoidType(const NIL_TYPE *type);
bool nilIsLabelType(const NIL_TYPE *type);
bool nilIsFloatType(const NIL_TYPE *type);
bool nilIsDoubleType(const NIL_TYPE *type);
bool nilIsIntegerType(const NIL_TYPE *type);
bool nilIsIntegerNType(const NIL_TYPE *type, enum_t n);
bool nilIsFunctionType(const NIL_TYPE *type);
bool nilIsStructType(const NIL_TYPE *type);
bool nilIsArrayType(const NIL_TYPE *type);
bool nilIsPointerType(const NIL_TYPE *type);
bool nilIsFirstClassType(const NIL_TYPE *type);
bool nilIsSingleValueType(const NIL_TYPE *type);
bool nilIsAggregateType(const NIL_TYPE *type);
bool nilIsSized(const NIL_TYPE *type);
size_t nilGetPrimitiveSizeInBits(const NIL_TYPE *type);
NIL_INTEGER_BITS nilGetIntegerBitWidth(const NIL_TYPE *type);
size_t nilGetFunctionNumParams(const NIL_TYPE *type);
const NIL_TYPE *nilGetFunctionParamType(const NIL_TYPE *type, size_t i);
bool nilIsFunctionVarArg(const NIL_TYPE *type);
NT_STRING *nilGetStructName(const NIL_TYPE *type);
size_t nilGetStructNumElements(const NIL_TYPE *type);
const NIL_TYPE *nilGetStructElementType(const NIL_TYPE *type, size_t n);
size_t nilGetArrayNumElements(const NIL_TYPE *type);
const NIL_TYPE *nilGetArrayElementType(const NIL_TYPE *type);
const NIL_TYPE *nilGetPointerTo(const NIL_TYPE *type);
bool nilIsValidElementType(const NIL_TYPE *elementType);
bool nilIsValidReturnType(const NIL_TYPE *type);
bool nilIsValidArgumentType(const NIL_TYPE *type);
bool nilIsOpaque(const NIL_TYPE *type);

#pragma endregion Type

#pragma region Value
/*************/
/* NIL_VALUE */
/*************/

/**
 * @ingroup Value
 * @brief This enum identifier type of value.
 * @typedef NIL_VALUE_TYPE
 * @see @ref NIL_VALUE
 */
enum _NIL_VALUE_TYPE
{
    NIL_VALUE_TYPE_ARGUMENT,
    NIL_VALUE_TYPE_BASIC_BLOCK,
    NIL_VALUE_TYPE_CONSTANT,
    NIL_VALUE_TYPE_INSTRUCTION,
};
typedef enum_t NIL_VALUE_TYPE;

/**
 * @ingroup Value
 * @typedef NIL_VALUE
 * @struct _NIL_VALUE
 * @brief This type represents a value/single assigned register.
 * @see @ref NIL_VALUE_TYPE
 */
struct _NIL_VALUE
{
    /// @brief Symbol table entry to identify the value.
    NIL_SYMBOL_TABLE_ENTRY entry;
    /// @brief Type of value.
    NIL_VALUE_TYPE type;
    /// @brief Debug information about code that generate this value.
    NIL_DEBUG_LOC dbgLoc;
};
typedef struct _NIL_VALUE NIL_VALUE;

/**
 * @ingroup Value
 * @struct _NIL_BASIC_BLOCK_LIST
 * @typedef NIL_BASIC_BLOCK_LIST
 * @brief This type represents a list of NIL_BASIC_BLOCK values.
 * @see @ref NIL_BASIC_BLOCK
 */
struct _NIL_BASIC_BLOCK_LIST
{
    /// @brief Number of basic blocks inside this list.
    size_t count;
    /// @brief Max number of basic blocks in current basicBlocks allocation.
    size_t size;
    /// @brief Pointer to basic blocks.
    struct _NIL_BASIC_BLOCK **values;
};
typedef struct _NIL_BASIC_BLOCK_LIST NIL_BASIC_BLOCK_LIST;

/**
 * @ingroup Value
 * @struct _NIL_CONSTANT
 * @typedef NIL_CONSTANT
 * @brief This type represents a constant.
 * @see @ref NIL_VALUE
 */
struct _NIL_CONSTANT
{
    /// @brief Base value.
    NIL_VALUE value;
    /// @brief Type of value.
    const NIL_TYPE *valueType;
    /// @brief Size of data field.
    size_t numBytes;
    /// @brief Constant data.
    uint8_t *data;
};
typedef struct _NIL_CONSTANT NIL_CONSTANT;

/**
 * @ingroup Instruction
 * @brief This enum indetifier type of instruction.
 * @typedef NIL_INST_TYPE
 * @see @ref NIL_INSTRUCTION
 */
enum _NIL_INST_TYPE
{
    NIL_INST_TYPE_BINARY_OPERATOR,
    NIL_INST_TYPE_BRANCH,
    NIL_INST_TYPE_CALL,
    NIL_INST_TYPE_CMP,
    NIL_INST_TYPE_LOAD,
    NIL_INST_TYPE_PHI_NODE,
    NIL_INST_TYPE_RETURN,
    NIL_INST_TYPE_SELECT,
    NIL_INST_TYPE_STORE,
};
typedef enum_t NIL_INST_TYPE;

/**
 * @ingroup Value
 * @struct _NIL_INSTRUCTION
 * @typedef NIL_INSTRUCTION
 * @brief This type represents a instruction value.
 */
struct _NIL_INSTRUCTION
{
    /// @brief Base value.
    NIL_VALUE value;
    /// @brief Block that contain this instruction.
    struct _NIL_BASIC_BLOCK *parent;
    /// @brief Instruction type.
    NIL_INST_TYPE type;
};
typedef struct _NIL_INSTRUCTION NIL_INSTRUCTION;

/**
 * @ingroup Value
 * @struct _NIL_INST_LIST
 * @typedef NIL_INST_LIST
 * @brief This type represents a list of instructions.
 */
struct _NIL_INST_LIST
{
    /// @brief Number of instruction inside this list.
    size_t count;
    /// @brief Max number of intructions in current instructions allocation.
    size_t size;
    /// @brief Pointer to instructions.
    NIL_INSTRUCTION **values;
};
typedef struct _NIL_INST_LIST NIL_INST_LIST;

/**
 * @ingroup Value
 * @struct _NIL_BASIC_BLOCK
 * @typedef NIL_BASIC_BLOCK
 * @brief This type represents a single basic block that is a container of
 * instructions that execute sequentially.
 */
struct _NIL_BASIC_BLOCK
{
    NIL_VALUE value;              // Base value
    struct _NIL_FUNCTION *parent; // Function that contain this basic block.
    NIL_INST_LIST *instList;      // Instruction list.
};
typedef struct _NIL_BASIC_BLOCK NIL_BASIC_BLOCK;

#pragma region Instruction

enum _NIL_BINARY_OPS
{
    NIL_BINARY_OP_ADD,
    NIL_BINARY_OP_FADD,
    NIL_BINARY_OP_SUB,
    NIL_BINARY_OP_FSUB,
    NIL_BINARY_OP_MUL,
    NIL_BINARY_OP_FMUL,
    NIL_BINARY_OP_UDIV,
    NIL_BINARY_OP_SDIV,
    NIL_BINARY_OP_FDIV,
    NIL_BINARY_OP_UREM,
    NIL_BINARY_OP_SREM,
    NIL_BINARY_OP_FREM,

    NIL_BINARY_OP_SHL, // Shift left  (logical)
    NIL_BINARY_OP_SHR, // Shift right (logical)
    NIL_BINARY_OP_ASR, // Shift right (arithmetic)
    NIL_BINARY_OP_AND,
    NIL_BINARY_OP_OR,
    NIL_BINARY_OP_XOR,

    NIL_BINARY_OPS_END,
    NIL_BINARY_OPS_BEGIN = NIL_BINARY_OP_ADD,
};
typedef enum_t NIL_BINARY_OPS;

/**
 * @ingroup Instructions
 * @struct _NIL_BINARY_OPERATOR
 * @typedef NIL_BINARY_OPERATOR
 * @brief This type represents a binary operator.
 * @see @ref NIL_INSTRUCTION
 */
struct _NIL_BINARY_OPERATOR
{
    /// @brief Base instruction.
    NIL_INSTRUCTION instruction;
    /// @brief Binary operation.
    NIL_BINARY_OPS op;
    /// @brief First source value.
    NIL_VALUE *source1;
    /// @brief Second source value.
    NIL_VALUE *source2;
};
typedef struct _NIL_BINARY_OPERATOR NIL_BINARY_OPERATOR;

/**
 * @ingroup Instructions
 * @brief This type represents conditional or unconditional branch instruction.
 * @struct _NIL_BRANCH
 * @typedef NIL_BRANCH
 * @see @ref NIL_INSTRUCTION
 * @see @ref NIL_BASIC_BLOCK
 * @see @ref NIL_VALUE
 */
struct _NIL_BRANCH
{
    /// @brief Base instruction.
    NIL_INSTRUCTION instruction;
    /// @brief Target basic block when condition is true.
    NIL_BASIC_BLOCK *ifTrue;
    /// @brief Target basic block when condition is false.
    NIL_BASIC_BLOCK *ifFalse;
    /// @brief Condition, when NULL the branch is uncoditional.
    NIL_VALUE *condition;
};
typedef struct _NIL_BRANCH NIL_BRANCH;

/**
 * @ingroup Instructions
 * @brief This type represents a function call.
 * @struct _NIL_CALL
 * @typedef NIL_CALL
 * @see @ref NIL_INSTRUCTION
 * @see @ref NIL_FUNCTION
 * @see @ref NIL_VALUE
 */
struct _NIL_CALL
{
    /// @brief Base instruction.
    NIL_INSTRUCTION instruction;
    /// @brief Function called.
    struct _NIL_FUNCTION *function;
    /// @brief Number of arguments.
    size_t numArgs;
    /// @brief Arguments.
    NIL_VALUE **arguments;
};

enum _NIL_CMP_PREDICATE
{
    /// @brief True if equal
    NIL_FCMP_EQ,
    /// @brief True if greater than
    NIL_FCMP_GT,
    /// @brief True if greater than or equal
    NIL_FCMP_GE,
    /// @brief True if less than
    NIL_FCMP_LT,
    /// @brief True if less than or equal
    NIL_FCMP_LE,
    /// @brief True if operands are unequal
    NIL_FCMP_NE,
    /// @brief True if ordered: (no nan)
    NIL_FCMP_OR,
    /// @brief True if unordered: isnan(x) | isnan(y)
    NIL_FCMP_UO,

    /// @brief True if equal
    NIL_ICMP_EQ,
    /// @brief True if unequal
    NIL_ICMP_NE,
    /// @brief True if unsigned greater than
    NIL_ICMP_UGT,
    /// @brief True if unsigned greater than or equal
    NIL_ICMP_UGE,
    /// @brief True if unsigned less than
    NIL_ICMP_ULT,
    /// @brief True if unsigned less than or equal
    NIL_ICMP_ULE,

    /// @brief True if signed greater than
    NIL_ICMP_SGT,
    /// @brief True if signed greater than or equal
    NIL_ICMP_SGE,
    /// @brief True if signed less than
    NIL_ICMP_SLT,
    /// @brief True if signed less than or equal
    NIL_ICMP_SLE,
};
typedef enum_t NIL_CMP_PREDICATE;

/**
 * @ingroup Instructions
 * @brief This type represents a compare instruction
 * @struct _NIL_CMP
 * @typedef NIL_CMP
 * @see @ref NIL_INSTRUCTION
 * @see @ref NIL_CMP_PREDICATE
 */
struct _NIL_CMP
{
    /// @brief Base instruction.
    NIL_INSTRUCTION instruction;
    /// @brief Comparison predicate.
    NIL_CMP_PREDICATE predicate;
    /// @brief First source value.
    NIL_VALUE *source1;
    /// @brief Second source value.
    NIL_VALUE *source2;
};
typedef struct _NIL_CMP NIL_CMP;

/**
 * @ingroup Instructions
 * @brief This type represents a load instruction for read from memory.
 * @struct _NIL_LOAD
 * @typedef NIL_LOAD
 * @see @ref NIL_INSTRUCTION
 * @see @ref NIL_TYPE
 * @see @ref NIL_VALUE
 * @see @ref NIL_STORE
 */
struct _NIL_LOAD
{
    /// @brief Base instruction.
    NIL_INSTRUCTION instruction;
    /// @brief Type of value to load.
    NIL_TYPE *valueType;
    /// @brief Pointer to value.
    NIL_VALUE *ptr;
};
typedef struct _NIL_LOAD NIL_LOAD;

/**
 * @ingroup Instructions
 * @brief This type represents a incoming value of PHI list
 * @struct _NIL_INCOMING_VALUE
 * @typedef NIL_INCOMING_VALUE
 * @see @ref NIL_INSTRUCTION
 * @see @ref NIL_VALUE
 * @see @ref NIL_BASIC_BLOCK
 * @see @ref NIL_INCOMING_LIST
 * @see @ref NIL_PHI_NODE
 */
struct _NIL_INCOMING_VALUE
{
    NIL_VALUE *value;
    NIL_BASIC_BLOCK *basicBlock;
};
typedef struct _NIL_INCOMING_VALUE NIL_INCOMING_VALUE;

/**
 * @ingroup Instructions
 * @struct _NIL_INCOMING_LIST
 * @typedef NIL_INCOMING_LIST
 * @brief This type represents a list of NIL_INCOMING_VALUE values.
 * @brief This type represents a list of NIL_INCOMING_VALUE values.
 * @see @ref NIL_VALUE
 * @see @ref NIL_BASIC_BLOCK
 * @see @ref NIL_INCOMING_VALUE
 * @see @ref NIL_PHI_NODE
 */
struct _NIL_INCOMING_LIST
{
    /// @brief Number of incoming values inside this list.
    size_t count;
    /// @brief Max number of incoming values in a PHI Node.
    size_t size;
    /// @brief Pointer to basic blocks.
    struct _NIL_BASIC_BLOCK **values;
};
typedef struct _NIL_INCOMING_LIST NIL_INCOMING_LIST;

/**
 * @ingroup Instructions
 * @brief This type represents a PHI instruction.
 * @struct _NIL_PHI_NODE
 * @typedef NIL_PHI_NODE
 * @see @ref NIL_INSTRUCTION
 * @see @ref NIL_INCOMING_VALUE
 * @see @ref NIL_INCOMING_LIST
 * @see @ref NIL_BASIC_BLOCK
 */
struct _NIL_PHI_NODE
{
    /// @brief Base instruction.
    NIL_INSTRUCTION instruction;
    /// @brief Incoming value list.
    NIL_INCOMING_LIST *incomingList;
};
typedef struct _NIL_PHI_NODE NIL_PHI_NODE;

/**
 * @ingroup Instructions
 * @brief This type represents a return instruction.
 * @struct _NIL_RETURN
 * @typedef NIL_RETURN
 * @see @ref NIL_INSTRUCTION
 * @see @ref NIL_FUNCTION
 * @see @ref NIL_BASIC_BLOCK
 */
struct _NIL_RETURN
{
    /// @brief Base instruction.
    NIL_INSTRUCTION instruction;
    /// @brief Return value (possibly NULL for void)
    NIL_VALUE *retValue;
};
typedef struct _NIL_RETURN NIL_RETURN;

/**
 * @ingroup Instructions
 * @brief This type represents a select instruction that choose one value based
 * on a condition, without IR branch.
 * @struct _NIL_RETURN
 * @typedef NIL_RETURN
 * @see @ref NIL_INSTRUCTION
 * @see @ref NIL_VALUE
 */
struct _NIL_SELECT
{
    /// @brief Base instruction.
    NIL_INSTRUCTION instruction;
    /// @brief A i1 value indicating the condition.
    NIL_VALUE *condition;
    /// @brief The result value when condition evaluates to 1.
    NIL_VALUE *trueValue;
    /// @brief The result value when condition evaluates to 0.
    NIL_VALUE *falseValue;
};
typedef struct _NIL_SELECT NIL_SELECT;

/**
 * @ingroup Instructions
 * @brief This type represents a store instruction for write to memory.
 * @struct _NIL_STORE
 * @typedef NIL_STORE
 * @see @ref NIL_INSTRUCTION
 * @see @ref NIL_TYPE
 * @see @ref NIL_VALUE
 * @see @ref NIL_LOAD
 */
struct _NIL_STORE
{
    /// @brief Base instruction.
    NIL_INSTRUCTION instruction;
    /// @brief Type of value to load.
    NIL_TYPE *valueType;
    /// @brief Value to write.
    NIL_VALUE *value;
    /// @brief Pointer to write address.
    NIL_VALUE *ptr;
};
typedef struct _NIL_STORE NIL_STORE;

#pragma endregion Instruction

#pragma endregion Value

struct _NIL_FUNCTION
{
    NIL_SYMBOL_TABLE_ENTRY entry; // Entry.
    const NIL_TYPE *functionType;

    NIL_SYMBOL_TABLE *valueSymbolTable;
    NIL_BASIC_BLOCK_LIST *basicBlockList;
};
typedef struct _NIL_FUNCTION NIL_FUNCTION;

/**************/
/* NIL_MODULE */
/**************/

struct _NIL_MODULE
{
    NIL_SYMBOL_TABLE_ENTRY entry; // Entry.
    NIL_SYMBOL_TABLE *globalList;
    NIL_SYMBOL_TABLE *functions;
    NT_STRING *sourceFileName;
};
typedef struct _NIL_MODULE NIL_MODULE;

/**
 * @brief Creates a new module with a name.
 *
 * @param name The name of new module.
 * @return NIL_MODULE* A new module with that name.
 */
NIL_MODULE *nilCreateModule(NT_STRING *name);

/**
 * @brief Destroys a module object.
 *
 * @param module The module to destroy.
 */
void nilDestroyModule(NIL_MODULE *module);

/**
 * @brief Gets source file name.
 *
 * @param module The module to get from.
 * @return const NIL_STRING* Pointer to name.
 */
NT_STRING *nilGetSourceFileName(NIL_MODULE *module);

/**
 * @brief Sets module source file name.
 *
 * @param module Module to set source file name.
 * @param sourceFileName New source file name.
 */
void nilSetSourceFileName(NIL_MODULE *module, NT_STRING *sourceFileName);

/**
 * @brief Sets module name.
 *
 * @param module Module to set name.
 * @param name New module name.
 */
void nilSetModuleIdentifier(NIL_MODULE *module, NT_STRING *name);

/**
 * @brief Lookup the specified function in the module. If it doesn't exist, add
 * a new function and return it. This function guarantees to return a constant
 * pointer to the specified function type. If function type are wrong, return
 * the function with right type.
 *
 * @param module Module to get function from.
 * @param name Function name.
 * @param type Function type.
 * @return NIL_FUNCTION* The function with that name.
 */
NIL_FUNCTION *nilGetOrInsertFunction(NIL_MODULE *module, NT_STRING *name,
                                     const NIL_TYPE *type);

/**
 * @brief Lookup the specified function in the module symbol table.
 *
 * @param module Module to get function from.
 * @param name Function name.
 * @return NIL_FUNCTION* The function that name, or if doesn't exist, NULL.
 */
NIL_FUNCTION *nilGetFunction(NIL_MODULE *module, NT_STRING *name);

#endif
